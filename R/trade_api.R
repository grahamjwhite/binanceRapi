# Binance Public Spot API
#
# OpenAPI Specifications for the Binance Public Spot API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)
#
# The version of the OpenAPI document: 1.0
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Trade operations
#' @description binanceRapi.Trade
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ ApiV3AccountGet } \emph{ Account Information (USER_DATA) }
#' Get current account information.  Weight(IP): 10
#'
#' \itemize{
#' \item \emph{ @param } recv.window integer
#' \item \emph{ @returnType } \link{Account} \cr
#'
#'
#' \item status code : 200 | Account details
#'
#' \item return type : Account 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ApiV3AllOrderListGet } \emph{ Query all OCO (USER_DATA) }
#' Retrieves all OCO based on provided optional parameters  Weight(IP): 10
#'
#' \itemize{
#' \item \emph{ @param } from.id integer
#' \item \emph{ @param } start.time integer
#' \item \emph{ @param } end.time integer
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } recv.window integer
#' \item \emph{ @returnType } list( \link{inline_response_200_6} ) \cr
#'
#'
#' \item status code : 200 | List of OCO orders
#'
#' \item return type : array[InlineResponse2006] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ApiV3AllOrdersGet } \emph{ All Orders (USER_DATA) }
#' Get all account orders; active, canceled, or filled..  - If &#x60;orderId&#x60; is set, it will get orders &gt;&#x3D; that &#x60;orderId&#x60;. Otherwise most recent orders are returned. - For some historical orders &#x60;cummulativeQuoteQty&#x60; will be &lt; 0, meaning the data is not available at this time. - If &#x60;startTime&#x60; and/or &#x60;endTime&#x60; provided, &#x60;orderId&#x60; is not required  Weight(IP): 10
#'
#' \itemize{
#' \item \emph{ @param } symbol character
#' \item \emph{ @param } order.id integer
#' \item \emph{ @param } start.time integer
#' \item \emph{ @param } end.time integer
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } recv.window integer
#' \item \emph{ @returnType } list( \link{orderDetails} ) \cr
#'
#'
#' \item status code : 200 | Current open orders
#'
#' \item return type : array[OrderDetails] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ApiV3MyTradesGet } \emph{ Account Trade List (USER_DATA) }
#' Get trades for a specific account and symbol.  If &#x60;fromId&#x60; is set, it will get id &gt;&#x3D; that &#x60;fromId&#x60;. Otherwise most recent orders are returned.  Weight(IP): 10
#'
#' \itemize{
#' \item \emph{ @param } symbol character
#' \item \emph{ @param } order.id integer
#' \item \emph{ @param } start.time integer
#' \item \emph{ @param } end.time integer
#' \item \emph{ @param } from.id integer
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } recv.window integer
#' \item \emph{ @returnType } list( \link{myTrade} ) \cr
#'
#'
#' \item status code : 200 | List of trades
#'
#' \item return type : array[MyTrade] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ApiV3OpenOrderListGet } \emph{ Query Open OCO (USER_DATA) }
#' Weight(IP): 3
#'
#' \itemize{
#' \item \emph{ @param } recv.window integer
#' \item \emph{ @returnType } list( \link{inline_response_200_7} ) \cr
#'
#'
#' \item status code : 200 | List of OCO orders
#'
#' \item return type : array[InlineResponse2007] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ApiV3OpenOrdersDelete } \emph{ Cancel all Open Orders on a Symbol (TRADE) }
#' Cancels all active orders on a symbol.\\ This includes OCO orders.  Weight(IP): 1
#'
#' \itemize{
#' \item \emph{ @param } symbol character
#' \item \emph{ @param } recv.window integer
#' \item \emph{ @returnType } list( \link{anyOf&lt;order,ocoOrder&gt;} ) \cr
#'
#'
#' \item status code : 200 | Cancelled orders
#'
#' \item return type : array[AnyOforderocoOrder] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ApiV3OpenOrdersGet } \emph{ Current Open Orders (USER_DATA) }
#' Get all open orders on a symbol. Careful when accessing this with no symbol.  Weight(IP):\\ &#x60;3&#x60; for a single symbol;\\ &#x60;40&#x60; when the symbol parameter is omitted;
#'
#' \itemize{
#' \item \emph{ @param } symbol character
#' \item \emph{ @param } recv.window integer
#' \item \emph{ @returnType } list( \link{orderDetails} ) \cr
#'
#'
#' \item status code : 200 | Current open orders
#'
#' \item return type : array[OrderDetails] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ApiV3OrderDelete } \emph{ Cancel Order (TRADE) }
#' Cancel an active order.  Either &#x60;orderId&#x60; or &#x60;origClientOrderId&#x60; must be sent.  Weight(IP): 1
#'
#' \itemize{
#' \item \emph{ @param } symbol character
#' \item \emph{ @param } order.id integer
#' \item \emph{ @param } orig.client.order.id character
#' \item \emph{ @param } new.client.order.id character
#' \item \emph{ @param } recv.window integer
#' \item \emph{ @returnType } \link{Order} \cr
#'
#'
#' \item status code : 200 | Cancelled order
#'
#' \item return type : Order 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ApiV3OrderGet } \emph{ Query Order (USER_DATA) }
#' Check an order&#39;s status.  - Either &#x60;orderId&#x60; or &#x60;origClientOrderId&#x60; must be sent. - For some historical orders &#x60;cummulativeQuoteQty&#x60; will be &lt; 0, meaning the data is not available at this time.  Weight(IP): 2
#'
#' \itemize{
#' \item \emph{ @param } symbol character
#' \item \emph{ @param } order.id integer
#' \item \emph{ @param } orig.client.order.id character
#' \item \emph{ @param } recv.window integer
#' \item \emph{ @returnType } \link{OrderDetails} \cr
#'
#'
#' \item status code : 200 | Order details
#'
#' \item return type : OrderDetails 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ApiV3OrderListDelete } \emph{ Cancel OCO (TRADE) }
#' Cancel an entire Order List  Canceling an individual leg will cancel the entire OCO  Weight(IP): 1
#'
#' \itemize{
#' \item \emph{ @param } symbol character
#' \item \emph{ @param } order.list.id integer
#' \item \emph{ @param } list.client.order.id character
#' \item \emph{ @param } new.client.order.id character
#' \item \emph{ @param } recv.window integer
#' \item \emph{ @returnType } \link{OcoOrder} \cr
#'
#'
#' \item status code : 200 | Report on deleted OCO
#'
#' \item return type : OcoOrder 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ApiV3OrderListGet } \emph{ Query OCO (USER_DATA) }
#' Retrieves a specific OCO based on provided optional parameters  Weight(IP): 2
#'
#' \itemize{
#' \item \emph{ @param } order.list.id integer
#' \item \emph{ @param } orig.client.order.id character
#' \item \emph{ @param } recv.window integer
#' \item \emph{ @returnType } \link{InlineResponse2005} \cr
#'
#'
#' \item status code : 200 | OCO details
#'
#' \item return type : InlineResponse2005 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ApiV3OrderOcoPost } \emph{ New OCO (TRADE) }
#' Send in a new OCO  - Price Restrictions:   - &#x60;SELL&#x60;: Limit Price &gt; Last Price &gt; Stop Price   - &#x60;BUY&#x60;: Limit Price &lt; Last Price &lt; Stop Price - Quantity Restrictions:     - Both legs must have the same quantity     - &#x60;ICEBERG&#x60; quantities however do not have to be the same - Order Rate Limit     - &#x60;OCO&#x60; counts as 2 orders against the order rate limit.      Weight(IP): 1
#'
#' \itemize{
#' \item \emph{ @param } symbol character
#' \item \emph{ @param } side Enum < [SELL, BUY] >
#' \item \emph{ @param } quantity numeric
#' \item \emph{ @param } price numeric
#' \item \emph{ @param } stop.price numeric
#' \item \emph{ @param } list.client.order.id character
#' \item \emph{ @param } limit.client.order.id character
#' \item \emph{ @param } limit.iceberg.qty numeric
#' \item \emph{ @param } stop.client.order.id character
#' \item \emph{ @param } stop.limit.price numeric
#' \item \emph{ @param } stop.iceberg.qty numeric
#' \item \emph{ @param } stop.limit.time.in.force Enum < [GTC, FOK, IOC] >
#' \item \emph{ @param } new.order.resp.type Enum < [ACK, RESULT, FULL] >
#' \item \emph{ @param } side.effect.type Enum < [NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY] >
#' \item \emph{ @param } recv.window integer
#' \item \emph{ @returnType } \link{InlineResponse2004} \cr
#'
#'
#' \item status code : 200 | New OCO details
#'
#' \item return type : InlineResponse2004 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ApiV3OrderPost } \emph{ New Order (TRADE) }
#' Send in a new order.  - &#x60;LIMIT_MAKER&#x60; are &#x60;LIMIT&#x60; orders that will be rejected if they would immediately match and trade as a taker. - &#x60;STOP_LOSS&#x60; and &#x60;TAKE_PROFIT&#x60; will execute a &#x60;MARKET&#x60; order when the &#x60;stopPrice&#x60; is reached. - Any &#x60;LIMIT&#x60; or &#x60;LIMIT_MAKER&#x60; type order can be made an iceberg order by sending an &#x60;icebergQty&#x60;. - Any order with an &#x60;icebergQty&#x60; MUST have &#x60;timeInForce&#x60; set to &#x60;GTC&#x60;. - &#x60;MARKET&#x60; orders using &#x60;quantity&#x60; specifies how much a user wants to buy or sell based on the market price. - &#x60;MARKET&#x60; orders using &#x60;quoteOrderQty&#x60; specifies the amount the user wants to spend (when buying) or receive (when selling) of the quote asset; the correct quantity will be determined based on the market liquidity and &#x60;quoteOrderQty&#x60;. - &#x60;MARKET&#x60; orders using &#x60;quoteOrderQty&#x60; will not break &#x60;LOT_SIZE&#x60; filter rules; the order will execute a quantity that will have the notional value as close as possible to &#x60;quoteOrderQty&#x60;. - same &#x60;newClientOrderId&#x60; can be accepted only when the previous one is filled, otherwise the order will be rejected.  Trigger order price rules against market price for both &#x60;MARKET&#x60; and &#x60;LIMIT&#x60; versions:  - Price above market price: &#x60;STOP_LOSS&#x60; &#x60;BUY&#x60;, &#x60;TAKE_PROFIT&#x60; &#x60;SELL&#x60; - Price below market price: &#x60;STOP_LOSS&#x60; &#x60;SELL&#x60;, &#x60;TAKE_PROFIT&#x60; &#x60;BUY&#x60;   Weight(IP): 1
#'
#' \itemize{
#' \item \emph{ @param } symbol character
#' \item \emph{ @param } side Enum < [SELL, BUY] >
#' \item \emph{ @param } type Enum < [LIMIT, MARKET, STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, TAKE_PROFIT_LIMIT, LIMIT_MAKER] >
#' \item \emph{ @param } time.in.force Enum < [GTC, IOC, FOK] >
#' \item \emph{ @param } quantity numeric
#' \item \emph{ @param } quote.order.qty numeric
#' \item \emph{ @param } price numeric
#' \item \emph{ @param } new.client.order.id character
#' \item \emph{ @param } stop.price numeric
#' \item \emph{ @param } iceberg.qty numeric
#' \item \emph{ @param } new.order.resp.type Enum < [ACK, RESULT, FULL] >
#' \item \emph{ @param } recv.window integer
#' \item \emph{ @returnType } \link{OneOforderResponseAckorderResponseResultorderResponseFull} \cr
#'
#'
#' \item status code : 200 | Order result
#'
#' \item return type : OneOforderResponseAckorderResponseResultorderResponseFull 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ApiV3OrderTestPost } \emph{ Test New Order (TRADE) }
#' Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.  Weight(IP): 1
#'
#' \itemize{
#' \item \emph{ @param } symbol character
#' \item \emph{ @param } side Enum < [SELL, BUY] >
#' \item \emph{ @param } type Enum < [LIMIT, MARKET, STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, TAKE_PROFIT_LIMIT, LIMIT_MAKER] >
#' \item \emph{ @param } time.in.force Enum < [GTC, IOC, FOK] >
#' \item \emph{ @param } quantity numeric
#' \item \emph{ @param } quote.order.qty numeric
#' \item \emph{ @param } price numeric
#' \item \emph{ @param } new.client.order.id character
#' \item \emph{ @param } stop.price numeric
#' \item \emph{ @param } iceberg.qty numeric
#' \item \emph{ @param } new.order.resp.type Enum < [ACK, RESULT, FULL] >
#' \item \emph{ @param } recv.window integer
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : object 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ApiV3RateLimitOrderGet } \emph{ Query Current Order Count Usage (TRADE) }
#' Displays the user&#39;s current order count usage for all intervals.  Weight(IP): 20
#'
#' \itemize{
#' \item \emph{ @param } recv.window integer
#' \item \emph{ @returnType } list( \link{inline_response_200_8} ) \cr
#'
#'
#' \item status code : 200 | Order rate limits
#'
#' \item return type : array[InlineResponse2008] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized Request
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  ApiV3AccountGet  ####################
#'
#' library(binanceRapi)
#' var.recv.window <- 5000 # integer | The value cannot be greater than 60000
#'
#' #Account Information (USER_DATA)
#' api.instance <- TradeApi$new()
#'
#' result <- api.instance$ApiV3AccountGet(recv.window=var.recv.window)
#'
#'
#' ####################  ApiV3AllOrderListGet  ####################
#'
#' library(binanceRapi)
#' var.from.id <- 56 # integer | Trade id to fetch from. Default gets most recent trades.
#' var.start.time <- 56 # integer | UTC timestamp in ms
#' var.end.time <- 56 # integer | UTC timestamp in ms
#' var.limit <- 500 # integer | Default 500; max 1000.
#' var.recv.window <- 5000 # integer | The value cannot be greater than 60000
#'
#' #Query all OCO (USER_DATA)
#' api.instance <- TradeApi$new()
#'
#' result <- api.instance$ApiV3AllOrderListGet(from.id=var.from.id, start.time=var.start.time, end.time=var.end.time, limit=var.limit, recv.window=var.recv.window)
#'
#'
#' ####################  ApiV3AllOrdersGet  ####################
#'
#' library(binanceRapi)
#' var.symbol <- 'BNBUSDT' # character | Trading symbol, e.g. BNBUSDT
#' var.order.id <- 56 # integer | Order id
#' var.start.time <- 56 # integer | UTC timestamp in ms
#' var.end.time <- 56 # integer | UTC timestamp in ms
#' var.limit <- 500 # integer | Default 500; max 1000.
#' var.recv.window <- 5000 # integer | The value cannot be greater than 60000
#'
#' #All Orders (USER_DATA)
#' api.instance <- TradeApi$new()
#'
#' result <- api.instance$ApiV3AllOrdersGet(var.symbol, order.id=var.order.id, start.time=var.start.time, end.time=var.end.time, limit=var.limit, recv.window=var.recv.window)
#'
#'
#' ####################  ApiV3MyTradesGet  ####################
#'
#' library(binanceRapi)
#' var.symbol <- 'BNBUSDT' # character | Trading symbol, e.g. BNBUSDT
#' var.order.id <- 56 # integer | This can only be used in combination with symbol.
#' var.start.time <- 56 # integer | UTC timestamp in ms
#' var.end.time <- 56 # integer | UTC timestamp in ms
#' var.from.id <- 56 # integer | Trade id to fetch from. Default gets most recent trades.
#' var.limit <- 500 # integer | Default 500; max 1000.
#' var.recv.window <- 5000 # integer | The value cannot be greater than 60000
#'
#' #Account Trade List (USER_DATA)
#' api.instance <- TradeApi$new()
#'
#' result <- api.instance$ApiV3MyTradesGet(var.symbol, order.id=var.order.id, start.time=var.start.time, end.time=var.end.time, from.id=var.from.id, limit=var.limit, recv.window=var.recv.window)
#'
#'
#' ####################  ApiV3OpenOrderListGet  ####################
#'
#' library(binanceRapi)
#' var.recv.window <- 5000 # integer | The value cannot be greater than 60000
#'
#' #Query Open OCO (USER_DATA)
#' api.instance <- TradeApi$new()
#'
#' result <- api.instance$ApiV3OpenOrderListGet(recv.window=var.recv.window)
#'
#'
#' ####################  ApiV3OpenOrdersDelete  ####################
#'
#' library(binanceRapi)
#' var.symbol <- 'BNBUSDT' # character | Trading symbol, e.g. BNBUSDT
#' var.recv.window <- 5000 # integer | The value cannot be greater than 60000
#'
#' #Cancel all Open Orders on a Symbol (TRADE)
#' api.instance <- TradeApi$new()
#'
#' result <- api.instance$ApiV3OpenOrdersDelete(var.symbol, recv.window=var.recv.window)
#'
#'
#' ####################  ApiV3OpenOrdersGet  ####################
#'
#' library(binanceRapi)
#' var.symbol <- 'BNBUSDT' # character | Trading symbol, e.g. BNBUSDT
#' var.recv.window <- 5000 # integer | The value cannot be greater than 60000
#'
#' #Current Open Orders (USER_DATA)
#' api.instance <- TradeApi$new()
#'
#' result <- api.instance$ApiV3OpenOrdersGet(symbol=var.symbol, recv.window=var.recv.window)
#'
#'
#' ####################  ApiV3OrderDelete  ####################
#'
#' library(binanceRapi)
#' var.symbol <- 'BNBUSDT' # character | Trading symbol, e.g. BNBUSDT
#' var.order.id <- 56 # integer | Order id
#' var.orig.client.order.id <- 'orig.client.order.id_example' # character | Order id from client
#' var.new.client.order.id <- 'new.client.order.id_example' # character | Used to uniquely identify this cancel. Automatically generated by default
#' var.recv.window <- 5000 # integer | The value cannot be greater than 60000
#'
#' #Cancel Order (TRADE)
#' api.instance <- TradeApi$new()
#'
#' result <- api.instance$ApiV3OrderDelete(var.symbol, order.id=var.order.id, orig.client.order.id=var.orig.client.order.id, new.client.order.id=var.new.client.order.id, recv.window=var.recv.window)
#'
#'
#' ####################  ApiV3OrderGet  ####################
#'
#' library(binanceRapi)
#' var.symbol <- 'BNBUSDT' # character | Trading symbol, e.g. BNBUSDT
#' var.order.id <- 56 # integer | Order id
#' var.orig.client.order.id <- 'orig.client.order.id_example' # character | Order id from client
#' var.recv.window <- 5000 # integer | The value cannot be greater than 60000
#'
#' #Query Order (USER_DATA)
#' api.instance <- TradeApi$new()
#'
#' result <- api.instance$ApiV3OrderGet(var.symbol, order.id=var.order.id, orig.client.order.id=var.orig.client.order.id, recv.window=var.recv.window)
#'
#'
#' ####################  ApiV3OrderListDelete  ####################
#'
#' library(binanceRapi)
#' var.symbol <- 'BNBUSDT' # character | Trading symbol, e.g. BNBUSDT
#' var.order.list.id <- 56 # integer | Order list id
#' var.list.client.order.id <- 'list.client.order.id_example' # character | A unique Id for the entire orderList
#' var.new.client.order.id <- 'new.client.order.id_example' # character | Used to uniquely identify this cancel. Automatically generated by default
#' var.recv.window <- 5000 # integer | The value cannot be greater than 60000
#'
#' #Cancel OCO (TRADE)
#' api.instance <- TradeApi$new()
#'
#' result <- api.instance$ApiV3OrderListDelete(var.symbol, order.list.id=var.order.list.id, list.client.order.id=var.list.client.order.id, new.client.order.id=var.new.client.order.id, recv.window=var.recv.window)
#'
#'
#' ####################  ApiV3OrderListGet  ####################
#'
#' library(binanceRapi)
#' var.order.list.id <- 56 # integer | Order list id
#' var.orig.client.order.id <- 'orig.client.order.id_example' # character | Order id from client
#' var.recv.window <- 5000 # integer | The value cannot be greater than 60000
#'
#' #Query OCO (USER_DATA)
#' api.instance <- TradeApi$new()
#'
#' result <- api.instance$ApiV3OrderListGet(order.list.id=var.order.list.id, orig.client.order.id=var.orig.client.order.id, recv.window=var.recv.window)
#'
#'
#' ####################  ApiV3OrderOcoPost  ####################
#'
#' library(binanceRapi)
#' var.symbol <- 'BNBUSDT' # character | Trading symbol, e.g. BNBUSDT
#' var.side <- 'SELL' # character | SELL or BUY
#' var.quantity <- 3.4 # numeric | 
#' var.price <- 3.4 # numeric | Order price
#' var.stop.price <- 3.4 # numeric | 
#' var.list.client.order.id <- 'list.client.order.id_example' # character | A unique Id for the entire orderList
#' var.limit.client.order.id <- 'limit.client.order.id_example' # character | A unique Id for the limit order
#' var.limit.iceberg.qty <- 3.4 # numeric | 
#' var.stop.client.order.id <- 'stop.client.order.id_example' # character | A unique Id for the stop loss/stop loss limit leg
#' var.stop.limit.price <- 3.4 # numeric | If provided, stopLimitTimeInForce is required.
#' var.stop.iceberg.qty <- 3.4 # numeric | 
#' var.stop.limit.time.in.force <- 'stop.limit.time.in.force_example' # character | 
#' var.new.order.resp.type <- 'new.order.resp.type_example' # character | Set the response JSON.
#' var.side.effect.type <- 'side.effect.type_example' # character | Default NO_SIDE_EFFECT
#' var.recv.window <- 5000 # integer | The value cannot be greater than 60000
#'
#' #New OCO (TRADE)
#' api.instance <- TradeApi$new()
#'
#' result <- api.instance$ApiV3OrderOcoPost(var.symbol, var.side, var.quantity, var.price, var.stop.price, list.client.order.id=var.list.client.order.id, limit.client.order.id=var.limit.client.order.id, limit.iceberg.qty=var.limit.iceberg.qty, stop.client.order.id=var.stop.client.order.id, stop.limit.price=var.stop.limit.price, stop.iceberg.qty=var.stop.iceberg.qty, stop.limit.time.in.force=var.stop.limit.time.in.force, new.order.resp.type=var.new.order.resp.type, side.effect.type=var.side.effect.type, recv.window=var.recv.window)
#'
#'
#' ####################  ApiV3OrderPost  ####################
#'
#' library(binanceRapi)
#' var.symbol <- 'BNBUSDT' # character | Trading symbol, e.g. BNBUSDT
#' var.side <- 'SELL' # character | SELL or BUY
#' var.type <- 'type_example' # character | Order type
#' var.time.in.force <- 'time.in.force_example' # character | Order time in force
#' var.quantity <- 3.4 # numeric | Order quantity
#' var.quote.order.qty <- 3.4 # numeric | Quote quantity
#' var.price <- 3.4 # numeric | Order price
#' var.new.client.order.id <- 'new.client.order.id_example' # character | Used to uniquely identify this cancel. Automatically generated by default
#' var.stop.price <- 20.01 # numeric | Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
#' var.iceberg.qty <- 3.4 # numeric | Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
#' var.new.order.resp.type <- 'new.order.resp.type_example' # character | Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
#' var.recv.window <- 5000 # integer | The value cannot be greater than 60000
#'
#' #New Order (TRADE)
#' api.instance <- TradeApi$new()
#'
#' result <- api.instance$ApiV3OrderPost(var.symbol, var.side, var.type, time.in.force=var.time.in.force, quantity=var.quantity, quote.order.qty=var.quote.order.qty, price=var.price, new.client.order.id=var.new.client.order.id, stop.price=var.stop.price, iceberg.qty=var.iceberg.qty, new.order.resp.type=var.new.order.resp.type, recv.window=var.recv.window)
#'
#'
#' ####################  ApiV3OrderTestPost  ####################
#'
#' library(binanceRapi)
#' var.symbol <- 'BNBUSDT' # character | Trading symbol, e.g. BNBUSDT
#' var.side <- 'SELL' # character | SELL or BUY
#' var.type <- 'type_example' # character | Order type
#' var.time.in.force <- 'time.in.force_example' # character | Order time in force
#' var.quantity <- 3.4 # numeric | Order quantity
#' var.quote.order.qty <- 3.4 # numeric | Quote quantity
#' var.price <- 3.4 # numeric | Order price
#' var.new.client.order.id <- 'new.client.order.id_example' # character | Used to uniquely identify this cancel. Automatically generated by default
#' var.stop.price <- 20.01 # numeric | Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
#' var.iceberg.qty <- 3.4 # numeric | Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
#' var.new.order.resp.type <- 'new.order.resp.type_example' # character | Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
#' var.recv.window <- 5000 # integer | The value cannot be greater than 60000
#'
#' #Test New Order (TRADE)
#' api.instance <- TradeApi$new()
#'
#' result <- api.instance$ApiV3OrderTestPost(var.symbol, var.side, var.type, time.in.force=var.time.in.force, quantity=var.quantity, quote.order.qty=var.quote.order.qty, price=var.price, new.client.order.id=var.new.client.order.id, stop.price=var.stop.price, iceberg.qty=var.iceberg.qty, new.order.resp.type=var.new.order.resp.type, recv.window=var.recv.window)
#'
#'
#' ####################  ApiV3RateLimitOrderGet  ####################
#'
#' library(binanceRapi)
#' var.recv.window <- 5000 # integer | The value cannot be greater than 60000
#'
#' #Query Current Order Count Usage (TRADE)
#' api.instance <- TradeApi$new()
#'
#' result <- api.instance$ApiV3RateLimitOrderGet(recv.window=var.recv.window)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
TradeApi <- R6::R6Class(
  'TradeApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    ApiV3AccountGet = function(recv.window=NULL, ...){
      apiResponse <- self$ApiV3AccountGetWithHttpInfo(recv.window, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ApiV3AccountGetWithHttpInfo = function(recv.window=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['recvWindow'] <- recv.window

      queryParams['timestamp'] <- self$apiClient$Timestamp

      queryParams['signature'] <- self$apiClient$credentials$sign(queryParams)

      body <- NULL
      urlPath <- "/api/v3/account"
      # API key authentication
      if (nchar(self$apiClient$credentials$key) > 0) {
        headerParams['X-MBX-APIKEY'] <- self$apiClient$credentials$key
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "Account", loadNamespace("binanceRapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ApiV3AllOrderListGet = function(from.id=NULL, start.time=NULL, end.time=NULL, limit=NULL, recv.window=NULL, ...){
      apiResponse <- self$ApiV3AllOrderListGetWithHttpInfo(from.id, start.time, end.time, limit, recv.window, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ApiV3AllOrderListGetWithHttpInfo = function(from.id=NULL, start.time=NULL, end.time=NULL, limit=NULL, recv.window=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['fromId'] <- from.id

      queryParams['startTime'] <- start.time

      queryParams['endTime'] <- end.time

      queryParams['limit'] <- limit

      queryParams['recvWindow'] <- recv.window

      queryParams['timestamp'] <- self$apiClient$Timestamp
      
      queryParams['signature'] <- self$apiClient$credentials$sign(queryParams)

      body <- NULL
      urlPath <- "/api/v3/allOrderList"
      # API key authentication
      if (nchar(self$apiClient$credentials$key) > 0) {
        headerParams['X-MBX-APIKEY'] <- self$apiClient$credentials$key
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[InlineResponse2006]", loadNamespace("binanceRapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ApiV3AllOrdersGet = function(symbol, order.id=NULL, start.time=NULL, end.time=NULL, limit=NULL, recv.window=NULL, ...){
      apiResponse <- self$ApiV3AllOrdersGetWithHttpInfo(symbol, order.id, start.time, end.time, limit, recv.window, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ApiV3AllOrdersGetWithHttpInfo = function(symbol, order.id=NULL, start.time=NULL, end.time=NULL, limit=NULL, recv.window=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`symbol`)) {
        stop("Missing required parameter `symbol`.")
      }

      queryParams['symbol'] <- symbol

      queryParams['orderId'] <- order.id

      queryParams['startTime'] <- start.time

      queryParams['endTime'] <- end.time

      queryParams['limit'] <- limit

      queryParams['recvWindow'] <- recv.window

      queryParams['timestamp'] <- self$apiClient$Timestamp

      queryParams['signature'] <- self$apiClient$credentials$sign(queryParams)

      body <- NULL
      urlPath <- "/api/v3/allOrders"
      # API key authentication
      if (nchar(self$apiClient$credentials$key) > 0) {
        headerParams['X-MBX-APIKEY'] <- self$apiClient$credentials$key
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[OrderDetails]", loadNamespace("binanceRapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ApiV3MyTradesGet = function(symbol, order.id=NULL, start.time=NULL, end.time=NULL, from.id=NULL, limit=NULL, recv.window=NULL, ...){
      apiResponse <- self$ApiV3MyTradesGetWithHttpInfo(symbol, order.id, start.time, end.time, from.id, limit, recv.window, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ApiV3MyTradesGetWithHttpInfo = function(symbol, order.id=NULL, start.time=NULL, end.time=NULL, from.id=NULL, limit=NULL, recv.window=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`symbol`)) {
        stop("Missing required parameter `symbol`.")
      }

      queryParams['symbol'] <- symbol

      queryParams['orderId'] <- order.id

      queryParams['startTime'] <- start.time

      queryParams['endTime'] <- end.time

      queryParams['fromId'] <- from.id

      queryParams['limit'] <- limit

      queryParams['recvWindow'] <- recv.window

      queryParams['timestamp'] <- self$apiClient$Timestamp
      
      queryParams['signature'] <- self$apiClient$credentials$sign(queryParams)

      body <- NULL
      urlPath <- "/api/v3/myTrades"
      # API key authentication
      if (nchar(self$apiClient$credentials$key) > 0) {
        headerParams['X-MBX-APIKEY'] <- self$apiClient$credentials$key
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[MyTrade]", loadNamespace("binanceRapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ApiV3OpenOrderListGet = function(recv.window=NULL, ...){
      apiResponse <- self$ApiV3OpenOrderListGetWithHttpInfo(recv.window, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ApiV3OpenOrderListGetWithHttpInfo = function(recv.window=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['recvWindow'] <- recv.window

      queryParams['timestamp'] <- self$apiClient$Timestamp
      
      queryParams['signature'] <- self$apiClient$credentials$sign(queryParams)

      body <- NULL
      urlPath <- "/api/v3/openOrderList"
      # API key authentication
      if (nchar(self$apiClient$credentials$key) > 0) {
        headerParams['X-MBX-APIKEY'] <- self$apiClient$credentials$key
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[InlineResponse2007]", loadNamespace("binanceRapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ApiV3OpenOrdersDelete = function(symbol, recv.window=NULL, ...){
      apiResponse <- self$ApiV3OpenOrdersDeleteWithHttpInfo(symbol, recv.window, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ApiV3OpenOrdersDeleteWithHttpInfo = function(symbol, recv.window=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`symbol`)) {
        stop("Missing required parameter `symbol`.")
      }

      queryParams['symbol'] <- symbol

      queryParams['recvWindow'] <- recv.window

      queryParams['timestamp'] <- self$apiClient$Timestamp
      
      queryParams['signature'] <- self$apiClient$credentials$sign(queryParams)

      body <- NULL
      urlPath <- "/api/v3/openOrders"
      # API key authentication
      if (nchar(self$apiClient$credentials$key) > 0) {
        headerParams['X-MBX-APIKEY'] <- self$apiClient$credentials$key
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[AnyOforderocoOrder]", loadNamespace("binanceRapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ApiV3OpenOrdersGet = function(symbol=NULL, recv.window=NULL, ...){
      apiResponse <- self$ApiV3OpenOrdersGetWithHttpInfo(symbol, recv.window, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ApiV3OpenOrdersGetWithHttpInfo = function(symbol=NULL, recv.window=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['symbol'] <- symbol

      queryParams['recvWindow'] <- recv.window

      queryParams['timestamp'] <- self$apiClient$Timestamp
      
      queryParams['signature'] <- self$apiClient$credentials$sign(queryParams)

      body <- NULL
      urlPath <- "/api/v3/openOrders"
      # API key authentication
      if (nchar(self$apiClient$credentials$key) > 0) {
        headerParams['X-MBX-APIKEY'] <- self$apiClient$credentials$key
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[OrderDetails]", loadNamespace("binanceRapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ApiV3OrderDelete = function(symbol, order.id=NULL, orig.client.order.id=NULL, new.client.order.id=NULL, recv.window=NULL, ...){
      apiResponse <- self$ApiV3OrderDeleteWithHttpInfo(symbol, order.id, orig.client.order.id, new.client.order.id, recv.window, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ApiV3OrderDeleteWithHttpInfo = function(symbol, order.id=NULL, orig.client.order.id=NULL, new.client.order.id=NULL, recv.window=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`symbol`)) {
        stop("Missing required parameter `symbol`.")
      }

      queryParams['symbol'] <- symbol

      queryParams['orderId'] <- order.id

      queryParams['origClientOrderId'] <- orig.client.order.id

      queryParams['newClientOrderId'] <- new.client.order.id

      queryParams['recvWindow'] <- recv.window

      queryParams['timestamp'] <- self$apiClient$Timestamp
      
      queryParams['signature'] <- self$apiClient$credentials$sign(queryParams)

      body <- NULL
      urlPath <- "/api/v3/order"
      # API key authentication
      if (nchar(self$apiClient$credentials$key) > 0) {
        headerParams['X-MBX-APIKEY'] <- self$apiClient$credentials$key
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "Order", loadNamespace("binanceRapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ApiV3OrderGet = function(symbol, order.id=NULL, orig.client.order.id=NULL, recv.window=NULL, ...){
      apiResponse <- self$ApiV3OrderGetWithHttpInfo(symbol, order.id, orig.client.order.id, recv.window, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ApiV3OrderGetWithHttpInfo = function(symbol, order.id=NULL, orig.client.order.id=NULL, recv.window=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`symbol`)) {
        stop("Missing required parameter `symbol`.")
      }

      queryParams['symbol'] <- symbol

      queryParams['orderId'] <- order.id

      queryParams['origClientOrderId'] <- orig.client.order.id

      queryParams['recvWindow'] <- recv.window

      queryParams['timestamp'] <- self$apiClient$Timestamp
      
      queryParams['signature'] <- self$apiClient$credentials$sign(queryParams)

      body <- NULL
      urlPath <- "/api/v3/order"
      # API key authentication
      if (nchar(self$apiClient$credentials$key) > 0) {
        headerParams['X-MBX-APIKEY'] <- self$apiClient$credentials$key
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "OrderDetails", loadNamespace("binanceRapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ApiV3OrderListDelete = function(symbol, order.list.id=NULL, list.client.order.id=NULL, new.client.order.id=NULL, recv.window=NULL, ...){
      apiResponse <- self$ApiV3OrderListDeleteWithHttpInfo(symbol, order.list.id, list.client.order.id, new.client.order.id, recv.window, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ApiV3OrderListDeleteWithHttpInfo = function(symbol, order.list.id=NULL, list.client.order.id=NULL, new.client.order.id=NULL, recv.window=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`symbol`)) {
        stop("Missing required parameter `symbol`.")
      }

      queryParams['symbol'] <- symbol

      queryParams['orderListId'] <- order.list.id

      queryParams['listClientOrderId'] <- list.client.order.id

      queryParams['newClientOrderId'] <- new.client.order.id

      queryParams['recvWindow'] <- recv.window

      queryParams['timestamp'] <- self$apiClient$Timestamp
      
      queryParams['signature'] <- self$apiClient$credentials$sign(queryParams)

      body <- NULL
      urlPath <- "/api/v3/orderList"
      # API key authentication
      if (nchar(self$apiClient$credentials$key) > 0) {
        headerParams['X-MBX-APIKEY'] <- self$apiClient$credentials$key
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "OcoOrder", loadNamespace("binanceRapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ApiV3OrderListGet = function(order.list.id=NULL, orig.client.order.id=NULL, recv.window=NULL, ...){
      apiResponse <- self$ApiV3OrderListGetWithHttpInfo(order.list.id, orig.client.order.id, recv.window, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ApiV3OrderListGetWithHttpInfo = function(order.list.id=NULL, orig.client.order.id=NULL, recv.window=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['orderListId'] <- order.list.id

      queryParams['origClientOrderId'] <- orig.client.order.id

      queryParams['recvWindow'] <- recv.window

      queryParams['timestamp'] <- self$apiClient$Timestamp
      
      queryParams['signature'] <- self$apiClient$credentials$sign(queryParams)

      body <- NULL
      urlPath <- "/api/v3/orderList"
      # API key authentication
      if (nchar(self$apiClient$credentials$key) > 0) {
        headerParams['X-MBX-APIKEY'] <- self$apiClient$credentials$key
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "InlineResponse2005", loadNamespace("binanceRapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ApiV3OrderOcoPost = function(symbol, side, quantity, price, stop.price, list.client.order.id=NULL, limit.client.order.id=NULL, limit.iceberg.qty=NULL, stop.client.order.id=NULL, stop.limit.price=NULL, stop.iceberg.qty=NULL, stop.limit.time.in.force=NULL, new.order.resp.type=NULL, side.effect.type=NULL, recv.window=NULL, ...){
      apiResponse <- self$ApiV3OrderOcoPostWithHttpInfo(symbol, side, quantity, price, stop.price, list.client.order.id, limit.client.order.id, limit.iceberg.qty, stop.client.order.id, stop.limit.price, stop.iceberg.qty, stop.limit.time.in.force, new.order.resp.type, side.effect.type, recv.window, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ApiV3OrderOcoPostWithHttpInfo = function(symbol, side, quantity, price, stop.price, list.client.order.id=NULL, limit.client.order.id=NULL, limit.iceberg.qty=NULL, stop.client.order.id=NULL, stop.limit.price=NULL, stop.iceberg.qty=NULL, stop.limit.time.in.force=NULL, new.order.resp.type=NULL, side.effect.type=NULL, recv.window=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`symbol`)) {
        stop("Missing required parameter `symbol`.")
      }

      if (missing(`side`)) {
        stop("Missing required parameter `side`.")
      }

      if (missing(`quantity`)) {
        stop("Missing required parameter `quantity`.")
      }

      if (missing(`price`)) {
        stop("Missing required parameter `price`.")
      }

      if (missing(`stop.price`)) {
        stop("Missing required parameter `stop.price`.")
      }

      queryParams['symbol'] <- symbol

      queryParams['listClientOrderId'] <- list.client.order.id

      queryParams['side'] <- side

      queryParams['quantity'] <- quantity

      queryParams['limitClientOrderId'] <- limit.client.order.id

      queryParams['price'] <- price

      queryParams['limitIcebergQty'] <- limit.iceberg.qty

      queryParams['stopClientOrderId'] <- stop.client.order.id

      queryParams['stopPrice'] <- stop.price

      queryParams['stopLimitPrice'] <- stop.limit.price

      queryParams['stopIcebergQty'] <- stop.iceberg.qty

      queryParams['stopLimitTimeInForce'] <- stop.limit.time.in.force

      queryParams['newOrderRespType'] <- new.order.resp.type

      queryParams['sideEffectType'] <- side.effect.type

      queryParams['recvWindow'] <- recv.window

      queryParams['timestamp'] <- self$apiClient$Timestamp
      
      queryParams['signature'] <- self$apiClient$credentials$sign(queryParams)

      body <- NULL
      urlPath <- "/api/v3/order/oco"
      # API key authentication
      if (nchar(self$apiClient$credentials$key) > 0) {
        headerParams['X-MBX-APIKEY'] <- self$apiClient$credentials$key
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "InlineResponse2004", loadNamespace("binanceRapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ApiV3OrderPost = function(symbol, side, type, time.in.force=NULL, quantity=NULL, quote.order.qty=NULL, price=NULL, new.client.order.id=NULL, stop.price=NULL, iceberg.qty=NULL, new.order.resp.type=NULL, recv.window=NULL, ...){
      apiResponse <- self$ApiV3OrderPostWithHttpInfo(symbol, side, type, time.in.force, quantity, quote.order.qty, price, new.client.order.id, stop.price, iceberg.qty, new.order.resp.type, recv.window, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ApiV3OrderPostWithHttpInfo = function(symbol, side, type, time.in.force=NULL, quantity=NULL, quote.order.qty=NULL, price=NULL, new.client.order.id=NULL, stop.price=NULL, iceberg.qty=NULL, new.order.resp.type=NULL, recv.window=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`symbol`)) {
        stop("Missing required parameter `symbol`.")
      }

      if (missing(`side`)) {
        stop("Missing required parameter `side`.")
      }

      if (missing(`type`)) {
        stop("Missing required parameter `type`.")
      }

      queryParams['symbol'] <- symbol

      queryParams['side'] <- side

      queryParams['type'] <- type

      queryParams['timeInForce'] <- time.in.force

      queryParams['quantity'] <- quantity

      queryParams['quoteOrderQty'] <- quote.order.qty

      queryParams['price'] <- price

      queryParams['newClientOrderId'] <- new.client.order.id

      queryParams['stopPrice'] <- stop.price

      queryParams['icebergQty'] <- iceberg.qty

      queryParams['newOrderRespType'] <- new.order.resp.type

      queryParams['recvWindow'] <- recv.window

      queryParams['timestamp'] <- self$apiClient$Timestamp
      
      queryParams['signature'] <- self$apiClient$credentials$sign(queryParams)

      body <- NULL
      urlPath <- "/api/v3/order"
      # API key authentication
      if (nchar(self$apiClient$credentials$key) > 0) {
        headerParams['X-MBX-APIKEY'] <- self$apiClient$credentials$key
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "OneOforderResponseAckorderResponseResultorderResponseFull", loadNamespace("binanceRapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ApiV3OrderTestPost = function(symbol, side, type, time.in.force=NULL, quantity=NULL, quote.order.qty=NULL, price=NULL, new.client.order.id=NULL, stop.price=NULL, iceberg.qty=NULL, new.order.resp.type=NULL, recv.window=NULL, ...){
      apiResponse <- self$ApiV3OrderTestPostWithHttpInfo(symbol, side, type, time.in.force, quantity, quote.order.qty, price, new.client.order.id, stop.price, iceberg.qty, new.order.resp.type, recv.window, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ApiV3OrderTestPostWithHttpInfo = function(symbol, side, type, time.in.force=NULL, quantity=NULL, quote.order.qty=NULL, price=NULL, new.client.order.id=NULL, stop.price=NULL, iceberg.qty=NULL, new.order.resp.type=NULL, recv.window=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`symbol`)) {
        stop("Missing required parameter `symbol`.")
      }

      if (missing(`side`)) {
        stop("Missing required parameter `side`.")
      }

      if (missing(`type`)) {
        stop("Missing required parameter `type`.")
      }

      queryParams['symbol'] <- symbol

      queryParams['side'] <- side

      queryParams['type'] <- type

      queryParams['timeInForce'] <- time.in.force

      queryParams['quantity'] <- quantity

      queryParams['quoteOrderQty'] <- quote.order.qty

      queryParams['price'] <- price

      queryParams['newClientOrderId'] <- new.client.order.id

      queryParams['stopPrice'] <- stop.price

      queryParams['icebergQty'] <- iceberg.qty

      queryParams['newOrderRespType'] <- new.order.resp.type

      queryParams['recvWindow'] <- recv.window

      queryParams['timestamp'] <- self$apiClient$Timestamp
      
      queryParams['signature'] <- self$apiClient$credentials$sign(queryParams)

      body <- NULL
      urlPath <- "/api/v3/order/test"
      # API key authentication
      if (nchar(self$apiClient$credentials$key) > 0) {
        headerParams['X-MBX-APIKEY'] <- self$apiClient$credentials$key
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "object", loadNamespace("binanceRapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ApiV3RateLimitOrderGet = function(recv.window=NULL, ...){
      apiResponse <- self$ApiV3RateLimitOrderGetWithHttpInfo(recv.window, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ApiV3RateLimitOrderGetWithHttpInfo = function(recv.window=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['recvWindow'] <- recv.window

      queryParams['timestamp'] <- self$apiClient$Timestamp
      
      queryParams['signature'] <- self$apiClient$credentials$sign(queryParams)

      body <- NULL
      urlPath <- "/api/v3/rateLimit/order"
      # API key authentication
      if (nchar(self$apiClient$credentials$key) > 0) {
        headerParams['X-MBX-APIKEY'] <- self$apiClient$credentials$key
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[InlineResponse2008]", loadNamespace("binanceRapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
